var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var node_1 = require("@sentry/node");
var utils_1 = require("@sentry/utils");
var SentryWebpackPlugin = require("@sentry/webpack-plugin");
var fs = require("fs");
var path = require("path");
var SENTRY_CLIENT_CONFIG_FILE = './sentry.client.config.js';
var SENTRY_SERVER_CONFIG_FILE = './sentry.server.config.js';
// this is where the transpiled/bundled version of `SENTRY_SERVER_CONFIG_FILE` will end up
exports.SERVER_SDK_INIT_PATH = 'sentry/initServerSDK.js';
/**
 * Add a file to a specific element of the given `entry` webpack config property.
 *
 * @param entryProperty The existing `entry` config object
 * @param injectionPoint The key where the file should be injected
 * @param injectee The path to the injected file
 */
var _injectFile = function (entryProperty, injectionPoint, injectee) {
    // can be a string, array of strings, or object whose `import` property is one of those two
    var injectedInto = entryProperty[injectionPoint];
    // Sometimes especially for older next.js versions it happens we don't have an entry point
    if (!injectedInto) {
        // eslint-disable-next-line no-console
        console.error("[Sentry] Can't inject " + injectee + ", no entrypoint is defined.");
        return;
    }
    // We inject the user's client config file after the existing code so that the config file has access to
    // `publicRuntimeConfig`. See https://github.com/getsentry/sentry-javascript/issues/3485
    if (typeof injectedInto === 'string') {
        injectedInto = [injectedInto, injectee];
    }
    else if (Array.isArray(injectedInto)) {
        injectedInto = tslib_1.__spread(injectedInto, [injectee]);
    }
    else {
        var importVal = void 0;
        if (typeof injectedInto.import === 'string') {
            importVal = [injectedInto.import, injectee];
        }
        else {
            importVal = tslib_1.__spread(injectedInto.import, [injectee]);
        }
        injectedInto = tslib_1.__assign(tslib_1.__assign({}, injectedInto), { import: importVal });
    }
    entryProperty[injectionPoint] = injectedInto;
};
var injectSentry = function (origEntryProperty, isServer) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
    var newEntryProperty;
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                newEntryProperty = origEntryProperty;
                if (!(typeof origEntryProperty === 'function')) return [3 /*break*/, 2];
                return [4 /*yield*/, origEntryProperty()];
            case 1:
                newEntryProperty = _a.sent();
                _a.label = 2;
            case 2:
                newEntryProperty = newEntryProperty;
                // Add a new element to the `entry` array, we force webpack to create a bundle out of the user's
                // `sentry.server.config.js` file and output it to `SERVER_INIT_LOCATION`. (See
                // https://webpack.js.org/guides/code-splitting/#entry-points.) We do this so that the user's config file is run
                // through babel (and any other processors through which next runs the rest of the user-provided code - pages, API
                // routes, etc.). Specifically, we need any ESM-style `import` code to get transpiled into ES5, so that we can call
                // `require()` on the resulting file when we're instrumenting the sesrver. (We can't use a dynamic import there
                // because that then forces the user into a particular TS config.)
                if (isServer) {
                    // slice off the final `.js` since webpack is going to add it back in for us, and we don't want to end up with
                    // `.js.js` as the extension
                    newEntryProperty[exports.SERVER_SDK_INIT_PATH.slice(0, -3)] = SENTRY_SERVER_CONFIG_FILE;
                }
                // On the client, it's sufficient to inject it into the `main` JS code, which is included in every browser page.
                else {
                    _injectFile(newEntryProperty, 'main', SENTRY_CLIENT_CONFIG_FILE);
                }
                return [2 /*return*/, newEntryProperty];
        }
    });
}); };
/**
 * Add Sentry options to the config to be exported from the user's `next.config.js` file.
 *
 * @param providedExports The existing config to be exported ,prior to adding Sentry
 * @param providedSentryWebpackPluginOptions Configuration for SentryWebpackPlugin
 * @returns The modified config to be exported
 */
function withSentryConfig(providedExports, providedSentryWebpackPluginOptions) {
    if (providedExports === void 0) { providedExports = {}; }
    if (providedSentryWebpackPluginOptions === void 0) { providedSentryWebpackPluginOptions = {}; }
    var defaultSentryWebpackPluginOptions = utils_1.dropUndefinedKeys({
        url: process.env.SENTRY_URL,
        org: process.env.SENTRY_ORG,
        project: process.env.SENTRY_PROJECT,
        authToken: process.env.SENTRY_AUTH_TOKEN,
        configFile: 'sentry.properties',
        stripPrefix: ['webpack://_N_E/'],
        urlPrefix: "~/_next",
        include: '.next/',
        ignore: ['.next/cache', 'server/ssr-module-cache.js', 'static/*/_ssgManifest.js', 'static/*/_buildManifest.js'],
    });
    // warn if any of the default options for the webpack plugin are getting overridden
    var sentryWebpackPluginOptionOverrides = Object.keys(defaultSentryWebpackPluginOptions)
        .concat('dryrun')
        .filter(function (key) { return key in providedSentryWebpackPluginOptions; });
    if (sentryWebpackPluginOptionOverrides.length > 0) {
        utils_1.logger.warn('[Sentry] You are overriding the following automatically-set SentryWebpackPlugin config options:\n' +
            ("\t" + sentryWebpackPluginOptionOverrides.toString() + ",\n") +
            "which has the possibility of breaking source map upload and application. This is only a good idea if you know what you're doing.");
    }
    var newWebpackExport = function (config, options) {
        // if we're building server code, store the webpack output path as an env variable, so we know where to look for the
        // webpack-processed version of `sentry.server.config.js` when we need it
        if (config.target === 'node') {
            var outputLocation = path.dirname(path.join(config.output.path, config.output.filename));
            var serverSDKInitOutputPath = path.join(outputLocation, exports.SERVER_SDK_INIT_PATH);
            var projectDir = config.context;
            setRuntimeEnvVars(projectDir, {
                // ex: .next/server/sentry/initServerSdk.js
                SENTRY_SERVER_INIT_PATH: path.relative(projectDir, serverSDKInitOutputPath),
            });
        }
        var newConfig = config;
        if (typeof providedExports.webpack === 'function') {
            newConfig = providedExports.webpack(config, options);
        }
        // Ensure quality source maps in production. (Source maps aren't uploaded in dev, and besides, Next doesn't let you
        // change this is dev even if you want to - see
        // https://github.com/vercel/next.js/blob/master/errors/improper-devtool.md.)
        if (!options.dev) {
            newConfig.devtool = 'source-map';
        }
        // Tell webpack to inject user config files (containing the two `Sentry.init()` calls) into the appropriate output
        // bundles. Store a separate reference to the original `entry` value to avoid an infinite loop. (In a synchronous
        // world, `x = () => f(x)` is fine, because the dereferencing is guaranteed to happen before the assignment, meaning
        // we know f will get the original value of x. But in an async world, if we do `x = async () => f(x)`, the
        // assignment happens *before* the dereferencing, meaning f is passed the new value. In other words, in that
        // scenario, the new value is defined in terms of itself, with predictably bad consequences. Theoretically this
        // could also be fixed by using `bind`, but this is way simpler.)
        var origEntryProperty = newConfig.entry;
        newConfig.entry = function () { return injectSentry(origEntryProperty, options.isServer); };
        // Add the Sentry plugin, which uploads source maps to Sentry when not in dev
        newConfig.plugins.push(
        // TODO it's not clear how to do this better, but there *must* be a better way
        new SentryWebpackPlugin(tslib_1.__assign(tslib_1.__assign({ dryRun: options.dev, release: node_1.getSentryRelease(options.buildId) }, defaultSentryWebpackPluginOptions), providedSentryWebpackPluginOptions)));
        return newConfig;
    };
    return tslib_1.__assign(tslib_1.__assign({}, providedExports), { productionBrowserSourceMaps: true, webpack: newWebpackExport });
}
exports.withSentryConfig = withSentryConfig;
/**
 * Set variables to be added to the env at runtime, by storing them in `.env.local` (which `next` automatically reads
 * into memory at server startup).
 *
 * @param projectDir The path to the project root
 * @param vars Object containing vars to set
 */
function setRuntimeEnvVars(projectDir, vars) {
    // ensure the file exists
    var envFilePath = path.join(projectDir, '.env.local');
    if (!fs.existsSync(envFilePath)) {
        fs.writeFileSync(envFilePath, '');
    }
    var fileContents = fs
        .readFileSync(envFilePath)
        .toString()
        .trim();
    Object.entries(vars).forEach(function (entry) {
        var _a = tslib_1.__read(entry, 2), varName = _a[0], value = _a[1];
        var envVarString = varName + "=" + value;
        // new entry
        if (!fileContents.includes(varName)) {
            fileContents = fileContents + "\n" + envVarString;
        }
        // existing entry; make sure value is up to date
        else {
            fileContents = fileContents.replace(new RegExp(varName + "=\\S+"), envVarString);
        }
    });
    fs.writeFileSync(envFilePath, fileContents.trim() + "\n");
}
//# sourceMappingURL=config.js.map